\section{Johdanto}

Ohjelmistojen haavoittuvuukset ovat verrattaen ikäviä:
Tietoturva-aukoista aiheutuneesta ylimääräisestä työstä tietojärjestelmien ylläpitäjille
sekä menetetystä työajasta voi seurata suuria rahallisia tappioita,
puhumattakaan mahdollisista henkilötietojen tai yrityssalaisuuksien vuotamisesta.
Esimerkiksi Microsoftin IIS-palvelimen haavoittuvuuden avulla levinneestä Code Red-madosta
arvioidaan aiheutuneen yhteensä noin 2,6 miljardin tappiot~\cite{CodeRed}.
Siksi on toivottavaa, että ohjelmiston tietoturvasta voidaan varmistua ennen ohjelmiston käyttöönottoa.

Tietoturvaongelmia voi yrittää löytää käsityönä tutkimalla ohjelman lähdekoodia,
mikä tietenkin on mahdollista vain ohjelmiston varsinaisille kehittäjille
tai avoimen lähdekoodin ohjelmille.
Lähdekoodin puuttuessa täytyy ensin ohjelmatiedosto takaisinkääntää
disassembler-ohjelmalla symboliselle konekielelle
ja tutkia ohjelmaa konekielitasolla.
Kummassakin tapauksessa manuaalinen tutkiminen on työlästä ja aikaavievää, joten automatisoitu ratkaisu on paikallaan.

\section{Yleisiä tietoturvaongelmia}

Tietoturvahaavoittuvuuden vakavuuteen vaikuttaa keskeisesti aiheutuuko siitä \emph{luottamusrajan}
(trust boundary) ylitys.
Esimerkiksi jos jokin palvelun kaatavan ohjelmointivirheen voi laukaista pelkästään järjestelmän
ylläpitäjä, ei kyseisellä virheellä ole suurta tietoturvamerkitystä.
Lähes samaan lopputulokseenhan päädytään jos ylläpitäjä sammuttaa palvelun tavallisia keinoja käyttämällä.
Sen sijaan jos vaikkapa Javascript-sovelmat selaimessa pääsee lukemaan käyttäjän tiedostoja,
on tilanne vakavampi, koska web-sivujen katselemisen tarkoitus on olla turvallista ja selaimen siten
kuuluu estää sovelmien pääsy tiedostojärjestelmään.
Vastaavaan tapaan tavallisen käyttäjän pääsy suorittamaan ohjelmia ylläpitäjän oikeuksilla
tai käyttöjärjestelmätilassa rikkoo luottamusrajan.

\subsection{Muistiturvallisuus}

Ohjelmointikieli vaikuttaa ratkaisevasti siihen miten laajoja seurauksia ohjelmointivirheillä voi olla tietoturvan kannalta.
Suurin ohjelmointikielestä riippuva tekijä on kielen \emph{muistiturvallisuus},
eli tunnistaako ajonaikainen ympäristö kiellettyjen muistiviitteiden tekemisen.
Nykypäivänä yleisimmät muistiturvallisuuden puutteesta kärsivät ohjelmointikielet ovat C ja C++,
joita tehokkuussyistä edelleen käytetään laajasti~\cite{StaticallyDetecting}.

Muistivirheet ilmenevät useimmiten prosessin tappamisena tietyllä
käyt\-tö\-jär\-jes\-tel\-mä\-koh\-tai\-sel\-la virhekoodilla.
Unix-pohjaisissa järjestelmissä tämä virhe on tunnettu `Segmentation fault'.
% ja Windows-järjestelmissä STATUS\_ACCESS\_VIOLATION.
Koska muistivirheistä aiheutuu useimmiten ohjelman kaatuminen,
mahdollistaa muistivirheen olemassaolo palvelunestohyökkäyksen eli DoS, denial-of-service-hyökkäyksen.
Lisäseurauksena prosessin pakotetusta kuolemasta on se,
ettei prosessilla ole mahdollisuutta siivota jotakin säilyvää tilaa,
esimerkiksi väliaikaistiedostoja.
Hallitsematon kuolema voi myös aiheuttaa tiedon korruptoitumista jos ohjelma kaatuu esimerkiksi kesken levykirjoitusta.
Kriittisimmät muistivirheet voivat mahdollistaa hyökkääjän suorittaa mielivaltaista koodia ohjelmaprosessin käyttöoikeuksilla (RCE, Remote Code Execution).

Muistivirheiksi luokitellaan tyypillisesti seuraavat:

\begin{itemize}
    \item Taulukon yli tai ali indeksointi: C-kielen taulukoissa ohjelmoijan vastuulla on huolehtia,
          ettei taulukkoa indeksoida liian suurella tai negatiivisella indeksillä.
          Jos näin pääsee tapahtumaan, kielen spesifikaatio ei ota kantaa siihen mitä tapahtuu.
          Käytännössä usein tapahtuu joko muistiviittaus taulukkoa ympäröiviin muuttujiin tai
            ajonaikaympäristön tietorakenteisiin.
          Suurin riski pinossa olevan taulukon ohi kirjoittamisessa onkin aktivaatiotietueessa
            sijaitsevan funktion paluuosoitteen ylikirjoittaminen.
          Tästä seuraa käytännössä suoraan mielivaltaisen koodin suoritus.
    \item Puskurin ylivuoto: Vastaavasti kuin taulukoiden kanssa,
          C-kielessä täytyy merkkijonoja ja tavupuskureita kopioitaessa tai luettaessa
             ohjelmoijan itse huolehtia, että puskurissa on riittävästi tilaa.
          Seuraukset ovat enimmäkseen samat kuin taulukon yli indeksoimisella.
          Puskureiden ylivuoto on C:ssä harmillisen helppo tehdä.
          Jo C:n standardikirjastosta löytyy funktioita~\cite{StaticallyDetecting},
          joille ei ole ollenkaan mahdollista antaa tulospuskurin kokoa ja siten aiheuttavat
          ylivuodon jos tulos ei mahdu puskuriin.
          Tällaisia funktioita ei koskaan pitäisi käyttää syötteen käsittelyn yhteydessä.
          Näistä syistä puskurin ylivuodot pinossa ovat ylivoimaisesti yleisin syy RCE-haavoittuvuuksille.
\end{itemize}

\section{Testausmenetelmät}

Ohjelmistotekniikan menetelmistä tuttu laadunvarmistustekniikka on automaattiset testit~\cite{Sommerville}.
Testausta voidaankin soveltaa tietoturvaongelmien välttämiseen tietyin edellytyksin:
sen sijaan, että testataan toivotun toiminnallisuuden olemassaoloa,
testataankin \emph{epätoivotun käytöksen} puutetta~\cite{OuluBrowser}.
Yleisempiä epätoivottuja tapahtumia ovat kaatumiset ja jumiutumiset (esimerkiksi ikisilmukat).

\subsection{Luokittelu}

Testauskeinoja voidaan tavallisten funktionaalisten testien tapaan luokitella karkeasti \emph{blackbox}- ja \emph{whitebox}-testeiksi sen mukaan kuinka paljon
testaaminen kohdistuu ohjelmiston tavanomaisiin rajapintoihin ja kuinka paljon ohjelmiston sisäisen rakenteen toimintaan~\cite{Sommerville}.

Blackbox-testauksessa ohjelmatiedostoa ajetaan aivan normaalisti,
ja tutkitaan sen käyttäytymistä ohjelmaan sopivilla syötteillä.
Esimerkiksi palvelinohjelmiston ollessa kyseessä siihen avataan verkkoyhteys,
tai komentoriviohjelmalle annetaan syöte normaalisti komentoriviparametrien kautta.

Whitebox-testauskeinoissa kajotaan ohjelman sisäiseen rakenteeseen.
Tä\-män\-kal\-tai\-seen testaukseen on tapoja huomattavasti enemmän.
Esimerkiksi jotkut keinot voivat vaatia pääsyä ohjelman lähdekoodiin,
tai sitten ohjelman suoritusta voidaan analysoida tai muuttaa konekielitasolla.

\subsection{Testauksen kriteereitä}

Tarkastellaan seuraavaksi muutamaa automaattista testausmenetelmää: \emph{staattista analyysiä} ja \emph{fuzzausta}.

\section{Staattinen analyysi}

Staattiseen analyysiin perustuvat keinot ovat lähdekoodin analyysiä tekeviä whitebox-menetelmiä.
Tällaiset menetelmät yrittävät paikantaa lähdekoodista tyypillisiä ohjelmointivirheitä.
Monista tällaisista ongelmista saattaa olla seuraamuksia tietoturvan kannalta~\cite{StaticCodeAnalysis}.
Yleisin tällainen keino on kääntäjien tarjoamat varoitukset ohjelmiston käännösaikana.
Usein käytettyjä staattisen analyysin työkaluja ohjelmointivirheiden etsintään
ovat \emph{lint}-tyyliset~\cite{Lint} ohjelmistot eri ohjelmointikielille sekä
esimerkiksi Coverity~\cite{Coverity}.

\subsection{Lint}

Lint~\cite{Lint} on varhainen C-kielisiä ohjelmia tarkistava staattisen analyysin työkalu vuodelta 1978.
Lintin fokuksena ei ollut tietoturvaongelmat,
vaan yksinkertaiset ohjelmointivirheet, C-kääntäjää tarkempi tyypintarkastus sekä siirrettävyysongelmat.
Esimerkiksi:

\begin{itemize}
    \item Alustamattoman muuttujan arvon käyttö.
    \item Käyttämättömät muuttujat tai funktiot.
    \item Saavuttamattomat koodirivit.
    \item ``järjettömät'' vertailut.
           Esimerkiksi etumerkittömälle kokonaislukumuuttujalle \texttt{x} ei ehtolauseke
           \texttt{if (x < 0)} ole koskaan tosi.
   \item Yllättävä operaattoripresedenssi.
         Esimerkiksi \texttt{if (x \& 0x10 == 0)} näyttää päällisin puolin bittitarkistukselta,
         mutta C:ssä \texttt{==}-operaattori sitoo \texttt{\&}-operaattoria vahvemmin,
         jollon ehtolausekkeen tulokseksi tulee aina 0.
\end{itemize}

Tuon ajan C-kääntäjissä kääntämisen nopeus oli korkeammalla prioriteetilla,
joten tämänkaltaisetkin kriittiset tarkastukset ulkoistettiin Lint-ohjelmalle.
Nykyiset kääntäjät osaavat varoittaa edellämainituista virheistä jo käännösaikana.

\section{Fuzzaus}

\emph{Fuzzaus} on raa'an voiman keino automaattiseen tietoturvatestaukseen.
Fuzzauksen tarkoitus on generoida satunnaisia syötteitä testattavalle ohjelmalle siinä toivossa,
että ohjelma ei käsittele niitä oikein~\cite{UnixReliability}.
Muun muassa aiemmin mainittuja muistivirheitä löytyy usein fuzzauksella:
normaalia reilusti pidemmät merkkijonot voivat ylivuotaa kiinteäkokoisia puskureita.
Samaten erikoisia merkkejä sisältävät merkkijonot sekä erittäin suuret tai negatiiviset lukuarvot
voivat olla ongelmallisia~\cite{ViolatingAssumptions}
esimerkiksi ylivuotamalla laskutoimituksia.

Fuzzaukselle hyvin sopivia kohteita ovat muun muassa erinäisten tiedostoformaattien jäsentäjät~\cite{SageArtikkeli,OuluBrowser}:
esimerkiksi web-selaimet joutuvat käsittelemään muun muassa
HTML-, CSS-, PNG- ja JavaScript-muotoisia tiedostoja~\cite{OuluBrowser}.
Tämä on varsin suuri määrä koodia,
joka ottaa syötteekseen tiedostoja suoraan lähtökohtaisesti epäturvallisesta Internetistä,
jolloin hyökkäyspinta-alaakin on runsaasti.

Fuzzaukseen sopivien syötteiden luontiin on olemassa runsaasti tekniikoita aina yksinkertaisista blackbox-menetelmistä monimutkaisempiin keinoihin:
\begin{itemize}
    \item Yksinkertaisimmillaan syöte voi olla lähes pelkkää satunnaista dataa.
          Esimerkiksi monien Unixin komentorivityökalujen syöte koostuu pelkistä tekstiriveistä
          ilman sen kummempaa rakennetta,
          jolloin jono rivinvaihdoilla eroteltua satunnaisgeneroituja
          tavuja~\cite{UnixReliability} on riittävä syöte ohjelmalle.
    \item Ennalta olemassa olevia kelvollisia syötteitä voidaan \emph{mutatoida} lisäämällä, poistamalla, muokkaamalla jne. satunnaisesti.
    \item Rakenteellisesti (enimmäkseen) kelvollisia, mutta normaalisti harvoin esiintyviä syötteitä voidaan luoda esimerkiksi kontekstittoman kieliopin tai jonkun muun formaalin syötteen määrittelyn perusteella.
    \item Ohjelman suoritusta voidaan analysoida symbolisesti välttämään syötteitä, jolla ei ole vaikutusta ohjelmaan~\cite{SageArtikkeli}.
\end{itemize}

\subsection{Testitapausten generointi}

\section{Yhteenveto}
Tässä tutkielmassa tarkasteltiin kahta menetelmää ohjelmistojen tietoturvatestaamiseen,
staattista analyysia ja fuzzausta.
Huomattavaa on, että koska osa tietoturvaongelmista on seurausta ohjelmointivirheistä,
niin tietoturvan parantamiseen soveltuu ohjelmointivirheitä yleisesti paikantavat ohjelmistotekniikan menetelmät.
Kuitenkin fuzzaus testausmenetelmänä on toimiva menetelmä erityisesti tietoturvaongelmien löytämiseen.
