\section{Johdanto}

Ohjelmistojen haavoittuvuukset ovat verrattaen ikäviä:
Tietoturva-aukoista aiheutuneesta ylimääräisestä työstä tietojärjestelmien ylläpitäjille
sekä menetetystä työajasta voi seurata suuria rahallisia tappioita,
puhumattakaan mahdollisista henkilötietojen tai yrityssalaisuuksien vuotamisesta.
Esimerkiksi Microsoftin IIS-palvelimen haavoittuvuuden avulla levinneestä Code Red-madosta
arvioidaan aiheutuneen yhteensä noin 2,6 miljardin tappiot~\cite{CodeRed}.
Siksi on toivottavaa, että ohjelmiston tietoturvasta voidaan varmistua ennen ohjelmiston käyttöönottoa.

Tietoturvaongelmia voi yrittää löytää käsityönä tutkimalla ohjelman lähdekoodia,
mikä tietenkin on mahdollista vain ohjelmiston varsinaisille kehittäjille
tai avoimen lähdekoodin ohjelmille.
Lähdekoodin puuttuessa täytyy ensin ohjelmatiedosto takaisinkääntää
disassembler-ohjelmalla symboliselle konekielelle
ja tutkia ohjelmaa konekielitasolla.
Kummassakin tapauksessa manuaalinen tutkiminen on työlästä ja aikaavievää, joten automatisoitu ratkaisu on paikallaan.

\section{Yleisiä tietoturvaongelmia}

Tietoturvahaavoittuvuuden vakavuuteen vaikuttaa keskeisesti aiheutuuko siitä \emph{luottamusrajan}
(trust boundary) ylitys.
Esimerkiksi jos jokin palvelun kaatavan ohjelmointivirheen voi laukaista pelkästään järjestelmän
ylläpitäjä, ei kyseisellä virheellä ole suurta tietoturvamerkitystä.
Lähes samaan lopputulokseenhan päädytään jos ylläpitäjä sammuttaa palvelun tavallisia keinoja käyttämällä.
Sen sijaan jos vaikkapa Javascript-sovelmat selaimessa pääsee lukemaan käyttäjän tiedostoja,
on tilanne vakavampi, koska web-sivujen katselemisen tarkoitus on olla turvallista ja selaimen siten
kuuluu estää sovelmien pääsy tiedostojärjestelmään.
Vastaavaan tapaan tavallisen käyttäjän pääsy suorittamaan ohjelmia ylläpitäjän oikeuksilla
tai käyttöjärjestelmätilassa rikkoo luottamusrajan.

\subsection{Muistiturvallisuus}

Ohjelmointikieli vaikuttaa ratkaisevasti siihen miten laajoja seurauksia ohjelmointivirheillä voi olla tietoturvan kannalta.
Suurin ohjelmointikielestä riippuva tekijä on kielen \emph{muistiturvallisuus},
eli tunnistaako ajonaikainen ympäristö kiellettyjen muistiviitteiden tekemisen.
Nykypäivänä yleisimmät muistiturvallisuuden puutteesta kärsivät ohjelmointikielet ovat C ja C++,
joita tehokkuussyistä edelleen käytetään laajasti~\cite{StaticallyDetecting}.

Muistivirheet ilmenevät useimmiten prosessin tappamisena tietyllä
käyt\-tö\-jär\-jes\-tel\-mä\-koh\-tai\-sel\-la virhekoodilla.
Unix-pohjaisissa järjestelmissä tämä virhe on tunnettu `Segmentation fault'.
% ja Windows-järjestelmissä STATUS\_ACCESS\_VIOLATION.
Koska muistivirheistä aiheutuu useimmiten ohjelman kaatuminen,
mahdollistaa muistivirheen olemassaolo palvelunestohyökkäyksen eli DoS, denial-of-service-hyökkäyksen.
Lisäseurauksena prosessin pakotetusta kuolemasta on se,
ettei prosessilla ole mahdollisuutta siivota jotakin säilyvää tilaa,
esimerkiksi väliaikaistiedostoja.
Hallitsematon kuolema voi myös aiheuttaa tiedon korruptoitumista jos ohjelma kaatuu esimerkiksi kesken levykirjoitusta.
Kriittisimmät muistivirheet voivat mahdollistaa hyökkääjän suorittaa mielivaltaista koodia ohjelmaprosessin käyttöoikeuksilla (RCE, Remote Code Execution).

Muistivirheiksi luokitellaan tyypillisesti seuraavat:

\begin{itemize}
    \item Taulukon yli tai ali indeksointi: C-kielen taulukoissa ohjelmoijan vastuulla on huolehtia,
          ettei taulukkoa indeksoida liian suurella tai negatiivisella indeksillä.
          Jos näin pääsee tapahtumaan, kielen spesifikaatio ei ota kantaa siihen mitä tapahtuu.
          Käytännössä usein tapahtuu joko muistiviittaus taulukkoa ympäröiviin muuttujiin tai
            ajonaikaympäristön tietorakenteisiin.
          Suurin riski pinossa olevan taulukon ohi kirjoittamisessa onkin aktivaatiotietueessa
            sijaitsevan funktion paluuosoitteen ylikirjoittaminen.
          Tästä seuraa käytännössä suoraan mielivaltaisen koodin suoritus.
    \item Puskurin ylivuoto: Vastaavasti kuin taulukoiden kanssa,
          C-kielessä täytyy merkkijonoja ja tavupuskureita kopioitaessa tai luettaessa
             ohjelmoijan itse huolehtia, että puskurissa on riittävästi tilaa.
          Seuraukset ovat enimmäkseen samat kuin taulukon yli indeksoimisella.
          Puskureiden ylivuoto on C:ssä harmillisen helppo tehdä.
          Jo C:n standardikirjastosta löytyy funktioita~\cite{StaticallyDetecting},
          joille ei ole ollenkaan mahdollista antaa tulospuskurin kokoa ja siten aiheuttavat
          ylivuodon jos tulos ei mahdu puskuriin.
          Tällaisia funktioita ei koskaan pitäisi käyttää syötteen käsittelyn yhteydessä.
          Näistä syistä puskurin ylivuodot pinossa ovat ylivoimaisesti yleisin syy RCE-haavoittuvuuksille.
    \item Alustamattoman muistin käyttö: C:ssä keosta tai paikallisille muuttujille varattua muistia
          alusteta mitenkään.
          Tällaisen muistialueen sisältönä on jotain mitä kyseisen muistialueen aiempi käyttäjä on
          sinne sattunut kirjoittamaan.
          Jos tällaista muistia sitten näytetään jossain muodossa käyttäjälle,
          saattaa käyttäjälle vuotaa joko ohjelman salaisia tietoja
          tai riittävästi tietoa ohjelman käyttämistä muistialueista helpottamaan RCE-haavoittuvuuden tekoa.
          Tai vaihtoehtoisesti alustamaton osoitinmuuttuja johtaa usein ohjelman kaatumiseen.

\end{itemize}
Edellisten lisäksi C-ohjelmoijan täytyy huoleehtia dynaamisesti varatun muistin vapauttamisesta.
Tästä aiheutuu vielä lisää mahdollisia virhetilanteita:

\begin{itemize}
    \item Muistivuodot: Jos ohjelmoija unohtaa vapauttaa dynaamisesti varatun muistialueen
          sen jälkeen kun sitä ei enää käytetä,
          jää tuo muistivaraus kuluttamaan muistia ohjelman sulkemiseen asti.
          Tämä mahdollistaa esimerkiksi palvelunestohyökkäyksen,
          mikäli lisääntynyt muistinkäyttö johtaa ohjelman sivutukseen levylle.
    \item Muistin vapauttaminen useasti (nk. double free):
          Varattua muistialuetta ei saa vapauttaa kuin yhden kerran,
          koska esimerkiksi vapauttamisen jälkeen sama muistialue voidaan antaa jonkun toisen
          muistivarauksen käyttöön,
          mikä näinollen aiheuttaisi jonkun toisen, täysin liittymättömän muistialueen vapauttamisen.
          Yleensä vapautetun muistialueen vapauttaminen uudelleen aiheuttaa muistinhallintakirjaston
          sisäisten tietorakenteiden korruptoitumisen ja
          johtaa ulkopuolisen koodin suoritukseen~\cite{DoubleFree}.

\end{itemize}

\section{Testausmenetelmät}

Ohjelmistotekniikan menetelmistä tuttu laadunvarmistustekniikka on automaattiset testit~\cite{Sommerville}.
Testausta voidaankin soveltaa tietoturvaongelmien välttämiseen tietyin edellytyksin:
sen sijaan, että testataan toivotun toiminnallisuuden olemassaoloa,
testataankin \emph{epätoivotun käytöksen} puutetta~\cite{OuluBrowser}.
Yleisempiä epätoivottuja tapahtumia ovat kaatumiset ja jumiutumiset (esimerkiksi ikisilmukat).

\subsection{Luokittelu}

Testauskeinoja voidaan tavallisten funktionaalisten testien tapaan luokitella karkeasti \emph{blackbox}- ja \emph{whitebox}-testeiksi sen mukaan kuinka paljon
testaaminen kohdistuu ohjelmiston tavanomaisiin rajapintoihin ja kuinka paljon ohjelmiston sisäisen rakenteen toimintaan~\cite{Sommerville}.

Blackbox-testauksessa ohjelmatiedostoa ajetaan aivan normaalisti,
ja tutkitaan sen käyttäytymistä ohjelmaan sopivilla syötteillä.
Esimerkiksi palvelinohjelmiston ollessa kyseessä siihen avataan verkkoyhteys,
tai komentoriviohjelmalle annetaan syöte normaalisti komentoriviparametrien kautta.

Whitebox-testauskeinoissa kajotaan ohjelman sisäiseen rakenteeseen.
Tä\-män\-kal\-tai\-seen testaukseen on tapoja huomattavasti enemmän.
Esimerkiksi jotkut keinot voivat vaatia pääsyä ohjelman lähdekoodiin,
tai sitten ohjelman suoritusta voidaan analysoida tai muuttaa konekielitasolla.

\subsection{Testauksen kriteereitä}

Tarkastellaan seuraavaksi muutamaa automaattista testausmenetelmää: \emph{staattista analyysiä} ja \emph{fuzzausta}.

\section{Staattinen analyysi}

Staattiseen analyysiin perustuvat keinot ovat lähdekoodin analyysiä tekeviä whitebox-menetelmiä.
Tällaiset menetelmät yrittävät paikantaa lähdekoodista tyypillisiä ohjelmointivirheitä.
Monista tällaisista ongelmista saattaa olla seuraamuksia tietoturvan kannalta~\cite{StaticCodeAnalysis}.
Yleisin tällainen keino on kääntäjien tarjoamat varoitukset ohjelmiston käännösaikana.
Usein käytettyjä staattisen analyysin työkaluja ohjelmointivirheiden etsintään
ovat \emph{lint}-tyyliset~\cite{Lint} ohjelmistot eri ohjelmointikielille sekä
esimerkiksi Coverity~\cite{Coverity}.

\subsection{Lint}

Lint~\cite{Lint} on varhainen C-kielisiä ohjelmia tarkistava staattisen analyysin työkalu vuodelta 1978.
Lintin fokuksena ei ollut tietoturvaongelmat,
vaan yksinkertaiset ohjelmointivirheet, C-kääntäjää tarkempi tyypintarkastus sekä siirrettävyysongelmat.
Esimerkiksi:

\begin{itemize}
    \item Alustamattoman muuttujan arvon käyttö.
    \item Käyttämättömät muuttujat tai funktiot.
    \item Saavuttamattomat koodirivit.
    \item ``järjettömät'' vertailut.
           Esimerkiksi etumerkittömälle kokonaislukumuuttujalle \texttt{x} ei ehtolauseke
           \texttt{if (x < 0)} ole koskaan tosi.
   \item Yllättävä operaattoripresedenssi.
         Esimerkiksi \texttt{if (x \& 0x10 == 0)} näyttää päällisin puolin bittitarkistukselta,
         mutta C:ssä \texttt{==}-operaattori sitoo \texttt{\&}-operaattoria vahvemmin,
         jollon ehtolausekkeen tulokseksi tulee aina 0.
\end{itemize}

Tuon ajan C-kääntäjissä kääntämisen nopeus oli korkeammalla prioriteetilla,
joten tämänkaltaisetkin kriittiset tarkastukset ulkoistettiin Lint-ohjelmalle.
Esimerkiksi C-kääntäjät tyypillisesti käsittelevät yhtä C-tiedostoa kerrallaan,
kun taas Lint tarkastelee tiedostoja kokonaisuutena,
mikä mahdollistaa tarkemman analyysin.
Nykyiset kääntäjät osaavat varoittaa edellämainituista virheistä jo käännösaikana.

Monet vastaavanlaiset staattisen analyysin työkalut eri kielille ovat nimetty
Lint-ohjelman mukaan, esimerkiksi JSLint JavaScript-kielelle.
Erityisesti C-kielen tietoturvaongelmiin keskittynyt staattisen analyysin ohjelmisto on Splint
(Secure Programming Lint), joka on aiemmin kulkenut nimellä LCLint.

Splint on keskittynyt löytämään samankaltaisia virheitä kuin Lint,
mutta lisäksi myös muistivirheitä sekä muistivuotoja C-kielisistä ohjelmista.
Muistivirheiden löytäminen tapahtuu esittämällä ohjelmakoodi nk. constraint solving-ongelmana
(mitä tämä on suomeksi?).
Ohjelmaan on määritelty jokaista C-kirjaston puskurinkäsittelyfunktiota kohti joukko
\emph{alkuehtoja}, joiden täytyy päteä funktiota kutsuttaessa.
Esimerkiksi kopioitaessa merkkijonoa \texttt{strcpy}-funktiolla ei osoitin kohde- tai lähdepuskuriin
saa olla \texttt{NULL} sekä kohdepuskurin täytyy olla vähintään yhtä suuri kuin lähdepuskurin.
Muistia varaavat funktiot ja konstruktiot sen sijaan tuottavat \emph{jälkiehtoja} -
esimerkiksi onnistuneen \texttt{malloc}-funktiokutsun tuloksena on puskuri, jonka
koko annettiin parametrinä.
Nyt jos Splint ei saa osoitettua, että alkuehdot pätevät aina,
varoittaa se mahdollisesta puskurin ylivuodosta.

\section{Fuzzaus}

\emph{Fuzzaus} on raa'an voiman keino automaattiseen tietoturvatestaukseen.
Fuzzauksen tarkoitus on generoida satunnaisia syötteitä testattavalle ohjelmalle siinä toivossa,
että ohjelma ei käsittele niitä oikein~\cite{UnixReliability}.
Muun muassa aiemmin mainittuja muistivirheitä löytyy usein fuzzauksella:
normaalia reilusti pidemmät merkkijonot voivat ylivuotaa kiinteäkokoisia puskureita.
Samaten erikoisia merkkejä sisältävät merkkijonot sekä erittäin suuret tai negatiiviset lukuarvot
voivat olla ongelmallisia~\cite{ViolatingAssumptions}
esimerkiksi ylivuotamalla laskutoimituksia.

Fuzzaukselle hyvin sopivia kohteita ovat muun muassa erinäisten tiedostoformaattien jäsentäjät~\cite{SageArtikkeli,OuluBrowser}:
esimerkiksi web-selaimet joutuvat käsittelemään muun muassa
HTML-, CSS-, PNG- ja JavaScript-muotoisia tiedostoja~\cite{OuluBrowser}.
Tämä on varsin suuri määrä koodia,
joka ottaa syötteekseen tiedostoja suoraan lähtökohtaisesti epäturvallisesta Internetistä,
jolloin hyökkäyspinta-alaakin on runsaasti.

Fuzzaukseen sopivien syötteiden luontiin on olemassa runsaasti tekniikoita aina yksinkertaisista blackbox-menetelmistä monimutkaisempiin keinoihin:
\begin{itemize}
    \item Yksinkertaisimmillaan syöte voi olla lähes pelkkää satunnaista dataa.
          Esimerkiksi monien Unixin komentorivityökalujen syöte koostuu pelkistä tekstiriveistä
          ilman sen kummempaa rakennetta,
          jolloin jono rivinvaihdoilla eroteltua satunnaisgeneroituja
          tavuja~\cite{UnixReliability} on riittävä syöte ohjelmalle.
    \item Ennalta olemassa olevia kelvollisia syötteitä voidaan \emph{mutatoida} lisäämällä, poistamalla, muokkaamalla jne. satunnaisesti.
    \item Rakenteellisesti (enimmäkseen) kelvollisia, mutta normaalisti harvoin esiintyviä syötteitä voidaan luoda esimerkiksi kontekstittoman kieliopin tai jonkun muun formaalin syötteen määrittelyn perusteella.
    \item Ohjelman suoritusta voidaan analysoida symbolisesti välttämään syötteitä, jolla ei ole vaikutusta ohjelmaan~\cite{SageArtikkeli}.
\end{itemize}

\subsection{Testitapausten generointi}

\section{Yhteenveto}
Tässä tutkielmassa tarkasteltiin kahta menetelmää ohjelmistojen tietoturvatestaamiseen,
staattista analyysia ja fuzzausta.
Huomattavaa on, että koska osa tietoturvaongelmista on seurausta ohjelmointivirheistä,
niin tietoturvan parantamiseen soveltuu ohjelmointivirheitä yleisesti paikantavat ohjelmistotekniikan menetelmät.
Kuitenkin fuzzaus testausmenetelmänä on toimiva menetelmä erityisesti tietoturvaongelmien löytämiseen.
